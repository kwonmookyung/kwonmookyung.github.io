<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>설문 결과 | 착한소상공인지원마켓</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="/assets/css/main.css" />
  <style>
    .container-narrow {
      max-width: 980px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .card {
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .08);
      padding: 1.3rem 1.3rem;
      margin-bottom: 1rem;
    }

    .card h2 {
      margin: 0 0 .6rem;
      font-size: 1.4rem;
    }

    .muted {
      color: #666;
      font-size: .95rem;
    }

    .pill {
      display: inline-block;
      padding: .35rem .7rem;
      border-radius: 999px;
      font-weight: 600;
      background: #111;
      color: #fff;
      font-size: .9rem;
    }

    .tag {
      display: inline-block;
      padding: .25rem .55rem;
      border-radius: 8px;
      border: 1px solid #ddd;
      margin-right: .35rem;
      margin-bottom: .35rem;
      font-size: .85rem;
    }

    .grid {
      display: grid;
      gap: 1rem;
    }

    @media(min-width:900px) {
      .grid-2 {
        grid-template-columns: 1fr 1fr;
      }
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
      border: 1px solid #222;
      border-radius: 10px;
      padding: .6rem 1rem;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .btn.secondary {
      background: #fff;
      color: #111;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    .codebox {
      background: #0b1020;
      color: #e5ecff;
      border-radius: 12px;
      padding: 1rem;
      white-space: pre-wrap;
      font-size: .9rem;
    }

    .small {
      font-size: .9rem;
    }

    .section-title {
      font-size: 1.1rem;
      letter-spacing: .02em;
      color: #444;
      margin-bottom: .4rem;
    }

    .divider {
      height: 1px;
      background: #eee;
      margin: .8rem 0 1.1rem;
    }

    .right {
      float: right;
    }

    .hide {
      display: none;
    }
  </style>
</head>

<body>
  <div id="page-wrapper">
    <!-- 사이트 헤더 (기존 네비 그대로 필요하면 복붙해서 쓰세요) -->
    <section id="main" class="wrapper style1" style="padding-top: 4.5em;">
      <div class="container container-narrow">

        <!-- 헤더: 유형 배지 + 이름 + 요약 -->
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
            <div>
              <div id="type-pill" class="pill">유형 로딩중...</div>
              <h1 id="type-name" style="margin:.4rem 0 0; font-size:1.8rem;">—</h1>
              <div id="type-tagline" class="muted">—</div>
            </div>
            <div class="right">
              <button id="btn-generate" class="btn">솔루션 전략 생성</button>
              <button id="btn-copy" class="btn secondary">복사</button>
            </div>
          </div>
        </div>

        <!-- 강점/단점 -->
        <div class="grid grid-2">
          <div class="card">
            <div class="section-title">강점</div>
            <div class="divider"></div>
            <ul id="strengths" style="margin:0; padding-left:1.1rem;"></ul>
          </div>
          <div class="card">
            <div class="section-title">단점</div>
            <div class="divider"></div>
            <ul id="weaknesses" style="margin:0; padding-left:1.1rem;"></ul>
          </div>
        </div>

        <!-- 솔루션 전략 (Gemini) -->
        <div class="card" id="ai-card">
          <div class="section-title">상황 맞춤 솔루션 전략</div>
          <div class="divider"></div>
          <div class="muted small">버튼을 누르면 축별로 순서대로 생성합니다. (S/I → W/T → L/R → Q/E)</div>

          <div style="margin-top:.6rem">
            <div class="muted small" id="st-si">S vs I · 생성 대기중</div>
            <div id="out-si" class="codebox mono hide"></div>
          </div>

          <div style="margin-top:1rem">
            <div class="muted small" id="st-wt">W vs T · 생성 대기중</div>
            <div id="out-wt" class="codebox mono hide"></div>
          </div>

          <div style="margin-top:1rem">
            <div class="muted small" id="st-lr">L vs R · 생성 대기중</div>
            <div id="out-lr" class="codebox mono hide"></div>
          </div>

          <div style="margin-top:1rem">
            <div class="muted small" id="st-qe">Q vs E · 생성 대기중</div>
            <div id="out-qe" class="codebox mono hide"></div>
          </div>
        </div>

        <!-- 메타 -->
        <div class="card small">
          <div class="section-title">결과 정보</div>
          <div class="divider"></div>
          <div id="meta" class="muted">
            UUID: <span id="meta-uuid">—</span> · 저장시각: <span id="meta-time">—</span><br />
            스코어: <span id="meta-scores" class="mono">—</span>
          </div>
        </div>

      </div>
    </section>
  </div>

  <!-- Firebase SDK (v9 모듈) -->
  <script type="module">
    /***** 설정 *****/
    const APP_ID = "survey-result"; // 레거시 fallback용 (artifacts 경로 쓸 때만)
    const firebaseConfig = {
      apiKey: "AIzaSyDhL9qWkfXRskWCwYh7E1E901luw1MvIK4",
      authDomain: "nbso-b7f41.firebaseapp.com",
      projectId: "nbso-b7f41",
      storageBucket: "nbso-b7f41.appspot.com",
      messagingSenderId: "94203359555",
      appId: "1:94203359555:web:07f9ee21d1291670363ff6",
      measurementId: "G-YCWF8ENKC4"
    };

    const TYPE_MAP_URL = "data/type-map.json?v=20250811"; // 외부 타입 데이터

    /***** Firebase 초기화 *****/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { parseGeminiSolution } from "/owner-survey/gemini-parser.js";
    window.GEMINI_API_KEY = "AIzaSyCxxCblNa3Vl7ORu-eS2KgjFPE9ArYkMfM";
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    async function ensureAnon() {
      const cur = auth.currentUser;
      if (cur) return cur;
      return new Promise((resolve, reject) => {
        const unsub = onAuthStateChanged(auth, (u) => { if (u) { unsub(); resolve(u); } });
        signInAnonymously(auth).catch(reject);
      });
    }

    function getUUID() {
      const p = new URLSearchParams(location.search);
      const u = p.get("uuid") || localStorage.getItem("surveyUUID");
      return u || "";
    }

    async function fetchResult(uuid) {
      const uid = auth.currentUser?.uid;
      if (uid) {
        const ref0 = doc(db, `users/${uid}/survey_results/${uuid}`);
        const snap0 = await getDoc(ref0).catch(() => null);
        if (snap0 && snap0.exists()) return { ref: ref0, snap: snap0, scope: "users" };
      }
      const refA = doc(db, `artifacts/${APP_ID}/public/data/survey_results/${uuid}`);
      const snapA = await getDoc(refA).catch(() => null);
      if (snapA && snapA.exists()) return { ref: refA, snap: snapA, scope: "artifacts" };

      const refB = doc(db, `survey_results/${uuid}`);
      const snapB = await getDoc(refB).catch(() => null);
      if (snapB && snapB.exists()) return { ref: refB, snap: snapB, scope: "top" };

      throw new Error("결과 문서를 찾을 수 없습니다.");
    }

    /***** 타입 맵 로드 *****/
    let TYPE_MAP = null;
    async function loadTypeMap() {
      try {
        const cached = localStorage.getItem("typeMap:v1");
        if (cached) TYPE_MAP = JSON.parse(cached);
      } catch { }
      try {
        const res = await fetch(TYPE_MAP_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("type-map fetch failed");
        const json = await res.json();
        if (json && typeof json === "object") {
          TYPE_MAP = json;
          try { localStorage.setItem("typeMap:v1", JSON.stringify(json)); } catch { }
        }
      } catch (e) {
        if (!TYPE_MAP) {
          console.warn("타입 맵 로드 실패, fallback 없음");
          TYPE_MAP = {};
        } else {
          console.warn("타입 맵 네트워크 실패, 캐시 사용");
        }
      }
    }
    function extractProfileFromResponses(responses) {
      const rows = responses || [];
      const find = (preds) => {
        const hit = rows.find(r => preds.some(p => p((r?.question || "").trim())));
        return (hit?.answer ?? "미입력") || "미입력";
      };

      return {
        industry: find([
          q => q === "당신의 업종은 무엇인가요?",
          q => q.includes("업종")
        ]),
        avg_daily_sales: find([
          q => q === "하루 평균 매출은 얼마인가요?",
          q => q.includes("하루") && q.includes("매출")
        ]),
        region: find([
          q => q === "가게가 위치한 지역은?",
          q => q.includes("지역")
        ]),
        operating_period: find([
          q => q === "운영 기간은 얼마나 되었나요?",
          q => q.includes("운영 기간")
        ]),
      };
    }
    function renderTypeCardWith(typeInfo, typeKey) {
      const d = typeInfo || null;
      const $pill = document.getElementById("type-pill");
      const $name = document.getElementById("type-name");
      const $tag = document.getElementById("type-tagline");
      const $str = document.getElementById("strengths");
      const $weak = document.getElementById("weaknesses");

      if (!d) {
        $pill.textContent = typeKey || "유형 미확정";
        $name.textContent = "—";
        $tag.textContent = "타입 데이터가 없습니다. (type-map.json 확인)";
        $str.innerHTML = ""; $weak.innerHTML = "";
        return;
      }
      $pill.textContent = typeKey;
      $name.textContent = d.name || "—";
      $tag.textContent = d.tagline || "";

      $str.innerHTML = "";
      (d.strengths || []).forEach(x => { const li = document.createElement("li"); li.textContent = x; $str.appendChild(li); });

      $weak.innerHTML = "";
      (d.weaknesses || []).forEach(x => { const li = document.createElement("li"); li.textContent = x; $weak.appendChild(li); });

      try { $pill.setAttribute("data-type", typeKey); } catch { }
    }

    function computeTypeFromScores(scores) {
      if (!scores) return null;
      const s1 = (scores.S ?? 0) >= (scores.I ?? 0) ? "S" : "I";
      const s2 = (scores.W ?? 0) >= (scores.T ?? 0) ? "W" : "T";
      const s3 = (scores.L ?? 0) >= (scores.R ?? 0) ? "L" : "R";
      const s4 = (scores.E ?? 0) >= (scores.Q ?? 0) ? "E" : "Q";
      return s1 + s2 + s3 + s4;
    }

    function showAI(text) {
      const out = document.getElementById("ai-output");
      const st = document.getElementById("ai-status");
      out.textContent = text;
      out.classList.remove("hide");
      st.textContent = "생성이 완료되었습니다.";
    }

    function setLoading(flag) {
      const btn = document.getElementById("btn-generate");
      const st = document.getElementById("ai-status");
      btn.disabled = flag;
      st.textContent = flag ? "Gemini가 솔루션을 생성 중입니다..." : "준비 완료.";
    }
    // === 축/사이드 계산 ===
    function getAxisSides(typeKey = "") {
      const t = String(typeKey || "").toUpperCase();
      return {
        SI: (t[0] === "S" ? "S" : "I"),
        WT: (t[1] === "W" ? "W" : "T"),
        LR: (t[2] === "L" ? "L" : "R"),
        QE: (t[3] === "Q" ? "Q" : "E"), // 주의: 기존 computeTypeFromScores는 E/Q 비교였지만, 코드 정의가 Q/E라면 여길 유지
      };
    }

    // === 축별 프롬프트 빌더 ===
    function buildAxisPrompt(axisKey, side, docData, typeKey, typeInfo) {
      const p = extractProfileFromResponses(docData?.responses);
      const axisLabel = {
        SI: "S vs I (운영자 성향)",
        WT: "W vs T (신규 유입 vs 단골 유지)",
        LR: "L vs R (논리형 vs 감각형 운영)",
        QE: "Q vs E (조직형 vs 감정형 응대)"
      }[axisKey] || axisKey;

      const lines = [];
      lines.push("당신은 한국의 소상공인 컨설턴트입니다. 친절하고 실천 가능한 조언을 한국어로 제공합니다.");
      lines.push(`사업자 MBTI 유형: ${typeKey} - ${typeInfo?.name || ""} (${typeInfo?.tagline || ""})`);
      lines.push(`축: ${axisLabel} · 사용자의 측면: ${side}`);
      lines.push("");
      lines.push("=== 사용자 핵심 정보(설문) ===");
      lines.push(`업종: ${p.industry}`);
      lines.push(`하루 평균 매출: ${p.avg_daily_sales}`);
      lines.push(`지역: ${p.region}`);
      lines.push(`운영 기간: ${p.operating_period}`);
      lines.push("");
      lines.push("요구사항:");
      lines.push("- 아래 JSON 형식으로만 간결하게 답하세요.");
      lines.push('- {"summary":"한 문장 요약", "evidence":["근거 2~4개(연구/통계 요지, 출처명만; 임의 생성 금지; 모르면 \'출처 미확정\')"], "recommendations":["실천 전략 4~6개"], "metrics":["필수 지표 3~5개"], "notes":["주의/한계 2~3개"]}');
      lines.push("- 플랫폼/채널의 실명은 쓰지 말고 '마케팅', '배달앱', 'SNS', '지도/검색', '동네 커뮤니티' 같은 일반 용어만 사용하세요.");
      lines.push("- 과학적/통계적 근거는 주장 대신 검증 가능한 형태로 요약하세요(수치 범위·경향·보고서 이름 등).");
      return lines.join("\n");
    }

    // === 축별 출력 도우미 ===
    function setAxisStatus(axisKey, text) {
      const id = { SI: "st-si", WT: "st-wt", LR: "st-lr", QE: "st-qe" }[axisKey];
      if (!id) return;
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    }
    function showAxisOutput(axisKey, text) {
      const id = { SI: "out-si", WT: "out-wt", LR: "out-lr", QE: "out-qe" }[axisKey];
      if (!id) return;
      const out = document.getElementById(id);
      if (out) { out.textContent = text; out.classList.remove("hide"); }
    }
    // JSON 파싱(관대하게)
    function safeParseJSON(raw) {
      if (!raw) return { ok: false, data: null, jsonText: "" };
      const pick = (s) => {
        // ```json ... ``` 또는 { ... } 블록 추출 시도
        const code = s.match(/```(?:json)?\s*([\s\S]*?)```/i);
        if (code) return code[1];
        const obj = s.match(/\{[\s\S]*\}$/m);
        return obj ? obj[0] : s;
      };
      const cand = pick(raw);
      try {
        const data = JSON.parse(cand);
        return { ok: true, data, jsonText: JSON.stringify(data, null, 2) };
      } catch {
        return { ok: false, data: null, jsonText: raw };
      }
    }

    async function callGemini(prompt) {
      if (window.GEMINI_ENDPOINT) {
        const r = await fetch(window.GEMINI_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt })
        });
        if (!r.ok) throw new Error("서버 응답 실패");
        return await r.text();
      }
      if (window.GEMINI_API_KEY) {
        const { GoogleGenerativeAI } = await import("https://esm.run/@google/generative-ai");
        const genAI = new GoogleGenerativeAI(window.GEMINI_API_KEY);
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const result = await model.generateContent(prompt);
        return result.response.text();
      }
      throw new Error("Gemini 호출 설정이 없습니다. (GEMINI_ENDPOINT 또는 GEMINI_API_KEY)");
    }

    document.getElementById("btn-generate").addEventListener("click", async () => {
      const btn = document.getElementById("btn-generate");
      btn.disabled = true;

      try {
        const sides = getAxisSides(typeKey);
        const axes = ["SI", "WT", "LR", "QE"];
        const results = {};

        for (const axis of axes) {
          setAxisStatus(axis, `${axis} · 생성 중...`);
          const prompt = buildAxisPrompt(axis, sides[axis], data, typeKey, TYPE_INFO);
          const raw = await callGemini(prompt);

          // 파싱(전용 파서가 아니라 관대한 파서 사용)
          const parsed = safeParseJSON(raw);
          const pretty = parsed.ok ? parsed.jsonText : (parsed.jsonText || raw);

          results[axis] = parsed.ok ? parsed.data : { raw };
          showAxisOutput(axis, pretty);
          setAxisStatus(axis, `${axis} · 생성 완료`);
        }

        // Firestore 저장(문서 소유자일 때만)
        const me = auth.currentUser?.uid || "";
        if (data.ownerUid && me && data.ownerUid === me) {
          await setDoc(ref, {
            aiAxisSolutions: results,
            aiAxisGeneratedAt: serverTimestamp()
          }, { merge: true });
        }
      } catch (err) {
        console.error(err);
        // 축 상태들에 에러를 표시
        ["SI", "WT", "LR", "QE"].forEach(ax => setAxisStatus(ax, `${ax} · 생성 실패`));
        document.getElementById("ai-card").insertAdjacentHTML(
          "beforeend",
          `<div class="muted small" style="margin-top:.8rem;color:#c00">오류: ${err?.message || err}</div>`
        );
      } finally {
        btn.disabled = false;
      }
    });

    /** 메인 */
    const uuid = getUUID();
    document.getElementById("meta-uuid").textContent = uuid || "—";

    try {
      await ensureAnon();
      await loadTypeMap(); // 타입맵 먼저 로드
      if (!uuid) throw new Error("uuid 파라미터가 없습니다.");

      const { ref, snap } = await fetchResult(uuid);
      const data = snap.data() || {};

      const ts = data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || null;
      document.getElementById("meta-time").textContent = ts ? ts.toLocaleString() : "—";

      const scores = data.finalScores || data.scores || data.score || null;
      document.getElementById("meta-scores").textContent = scores ? JSON.stringify(scores) : "—";

      // (선택) 메타 카드에 4가지 핵심 정보도 보여주기
      const prof = extractProfileFromResponses(data?.responses);
      document.getElementById("meta").insertAdjacentHTML(
        "beforeend",
        `<br/>업종: <b>${prof.industry}</b> · 하루 평균 매출: <b>${prof.avg_daily_sales}</b> · 지역: <b>${prof.region}</b> · 운영 기간: <b>${prof.operating_period}</b>`
      );

      // ✅ 파이어스토어의 유형을 1순위로 사용 (finalType → motiType → type)
      let typeKey = String(data.finalType || data.motiType || data.type || "").toUpperCase();
      if (!typeKey) {
        throw new Error("문서에 유형(finalType/motiType/type)이 없습니다. 결과 저장 로직을 확인해주세요.");
      }

      // type-map.json에서 한 번만 꺼내서 고정(화면+프롬프트는 이 값만 사용)
      const TYPE_INFO = Object.freeze(TYPE_MAP?.[typeKey] || null);

      // ✅ 화면 렌더는 무조건 type-map.json 기준
      renderTypeCardWith(TYPE_INFO, typeKey);

      document.getElementById("btn-generate").addEventListener("click", async () => {
        try {
          setLoading(true);
          const prompt = buildPrompt(
            data,
            typeKey,
            TYPE_INFO || { name: "", tagline: "", strengths: [], weaknesses: [] }
          );
          const raw = await callGemini(prompt);

          // ✅ 전용 파서로 견고하게 파싱
          const parsed = parseGeminiSolution(raw);
          const pretty = parsed.ok ? parsed.jsonText : (parsed.jsonText || raw);
          showAI(pretty);
          if (!parsed.ok && parsed.warning) {
            document.getElementById("ai-status").textContent =
              "주의: " + parsed.warning + " — 원문/후보를 표시합니다.";
          }

          const me = auth.currentUser?.uid || "";
          if (data.ownerUid && me && data.ownerUid === me) {
            await setDoc(ref, {
              aiSolution: parsed.ok ? parsed.data : { raw },
              aiGeneratedAt: serverTimestamp(),
              aiParseStatus: parsed.ok ? "ok" : "fallback"
            }, { merge: true });
          }
        } catch (err) {
          document.getElementById("ai-status").textContent = "생성 실패: " + (err?.message || err);
        } finally {
          setLoading(false);
        }
      });

    } catch (e) {
      document.getElementById("type-pill").textContent = "오류";
      document.getElementById("type-name").textContent = "결과를 불러오지 못했습니다";
      document.getElementById("type-tagline").textContent = e?.message || String(e);
      document.getElementById("btn-generate").disabled = true;
    }
    // [교체 끝]
  </script>
</body>

</html>